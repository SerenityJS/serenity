import {
  ActorDamageCause,
  ActorDataId,
  ActorDataType,
  ActorFlag,
  AnimateEntityPacket,
  ContainerId,
  ContainerName,
  EffectType,
  MoveActorDeltaPacket,
  MoveDeltaFlags,
  Rotation,
  UpdateAttributesPacket,
  Vector3f
} from "@serenityjs/protocol";
import { BaseTag, CompoundTag } from "@serenityjs/nbt";

import { Dimension, World } from "../world";
import {
  CardinalDirection,
  EntityIdentifier,
  EntityInteractMethod
} from "../enums";
import {
  CommandResponse,
  EntityDeathOptions,
  EntityDespawnOptions,
  EntityEffectOptions,
  EntityProperties,
  EntitySpawnOptions,
  JSONLikeValue
} from "../types";
import { Serenity } from "../serenity";
import { Chunk } from "../world/chunk";
import { Container } from "../container";
import { ItemStackBundleTrait, ItemStack } from "../item";
import { CommandExecutionState } from "../commands";
import {
  EntityDespawnedSignal,
  EntityDiedSignal,
  EntityDimensionChangeSignal,
  EntityDropItemSignal,
  EntityHitSignal,
  EntitySpawnedSignal,
  PlayerInteractWithEntitySignal
} from "../events";
import { ScoreboardIdentity } from "../world/scoreboard";

import { EntityType } from "./identity";
import {
  EntityCollisionTrait,
  EntityEffectsTrait,
  EntityEquipmentTrait,
  EntityGravityTrait,
  EntityInventoryTrait,
  EntityNameableTrait,
  EntityTrait,
  PlayerEntityRenderingTrait
} from "./traits";
import { Player } from "./player";
import { EntityInputInfo } from "./input-info";
import { EntityLevelStorage } from "./storage";
import { PlayerAnimationOptions } from "./types";
import { EntitySharedProperties } from "./shared-properties";
import { EntityActorFlags } from "./actor-flags";
import { EntityActorMetadata } from "./actor-metadata";
import { EntityAttributes } from "./attributes";

class Entity {
  /**
   * The running total of entities that have been created
   */
  public static runtimeId = 0n;

  /**
   * The serenity instance of the server
   */
  protected readonly serenity: Serenity;

  /**
   * The type of the entity.
   */
  public readonly type: EntityType;

  /**
   * The identifier of the entity.
   */
  public readonly identifier: EntityIdentifier;

  /**
   * The current runtime id of the entity. (Incremented each time an entity is created)
   */
  public readonly runtimeId = ++Entity.runtimeId;

  /**
   * The unique id of the entity. (Generated by the server, and exists for the lifetime of the entity)
   */
  public get uniqueId(): bigint {
    return this.storage.getUniqueId();
  }

  /**
   * The current velocity of the entity
   */
  public readonly velocity = new Vector3f(0, 0, 0);

  /**
   * The current rotation of the entity
   */
  public get rotation(): Rotation {
    return this.storage.getRotation();
  }

  /**
   * The traits that are attached to the entity
   */
  public readonly traits = new Map<string, EntityTrait>();

  /**
   * The components that are attached to the entity
   */
  public readonly dynamicProperties = new Map<string, JSONLikeValue>();

  /**
   * The shared properties that are attached to the entity.
   * These properites are shared to the client to be used in resource pack elements.
   * They can also be queried via the `molang` engine for use in resource packs.
   */
  public readonly sharedProperties: EntitySharedProperties;

  /**
   * The metadata that is attached to the entity
   * These values are derived from the components and traits of the entity
   */
  public readonly metadata: EntityActorMetadata;

  /**
   * The flags that are attached to the entity
   * These values are derived from the components and traits of the entity
   */
  public readonly flags: EntityActorFlags;

  /**
   * The attributes that are attached to the entity
   * These values are derived from the components and traits of the entity
   */
  public readonly attributes: EntityAttributes;

  /**
   *
   */
  protected readonly storage: EntityLevelStorage;

  /**
   * The tags that are attached to the entity
   */
  public readonly tags = new Set<string>();

  /**
   * The input info of the entity
   */
  public readonly inputInfo = new EntityInputInfo();

  /**
   * The scoreboard identity of the entity.
   */
  public scoreboardIdentity: ScoreboardIdentity;

  /**
   * The current dimension of the entity.
   * This should not be dynamically changed, but instead use the `teleport` method.
   */
  public dimension: Dimension;

  /**
   * The last entity that hit the entity.
   */
  private lastDamageSource: Entity | null = null;

  /**
   * The timestamp of the last damage event.
   */
  private lastDamageStamp: bigint = 0n;

  /**
   * Whether the entity is alive or not.
   */
  public isAlive = false;

  /**
   * Whether the entity is moving or not.
   */
  public isMoving = false;

  /**
   * Whether the entity is falling or not.
   */
  public isFalling = false;

  /**
   * Whether the entity is on the ground or not.
   */
  public onGround = false;

  /**
   * Whether the entity is currently ticking or not.
   * If true, this means the behaviors of the entity are being processed.
   * If false, this means the entity currently isn't within the simulation distance from a player.
   */
  public isTicking = true;

  public get lastAttacker(): Entity | null {
    const currentTick = this.world.currentTick;

    if (currentTick - this.lastDamageStamp > 20n) {
      this.lastDamageSource = null;
    }
    return this.lastDamageSource;
  }

  /**
   * The variant index of the entity.
   */
  public get variant(): number {
    // Check if the entity has a variant metadata
    if (!this.metadata.hasActorMetadata(ActorDataId.Variant)) return 0;

    // Get the variant metadata
    const variant = this.metadata.getActorMetadata(
      ActorDataId.Variant,
      ActorDataType.Int
    );

    // Return the variant metadata
    return variant ?? 0;
  }

  /**
   * The variant index of the entity.
   */
  public set variant(value: number) {
    // Set the variant metadata
    this.metadata.setActorMetadata(
      ActorDataId.Variant,
      ActorDataType.Int,
      value
    );
  }

  /**
   * The scale of the entity.
   */
  public get scale(): number {
    // Check if the entity has a scale metadata
    if (!this.metadata.hasActorMetadata(ActorDataId.Reserved038)) return 1;

    // Get the scale metadata
    const scale = this.metadata.getActorMetadata(
      ActorDataId.Reserved038,
      ActorDataType.Float
    );

    // Return the scale metadata
    return scale ?? 1;
  }

  /**
   * The scale of the entity.
   */
  public set scale(value: number) {
    // Set the scale metadata
    this.metadata.setActorMetadata(
      ActorDataId.Reserved038,
      ActorDataType.Float,
      value
    );
  }

  /**
   * Creates a new entity within a dimension.
   * @param dimension The dimension to create the entity in
   * @param type The type of the entity to create
   * @param properties Additional properties to assign to the entity
   */
  public constructor(
    dimension: Dimension,
    type: EntityType | EntityIdentifier | string,
    properties?: Partial<EntityProperties>
  ) {
    // Assign the serenity instance to the entity
    this.serenity = dimension.world.serenity;

    // Assign the dimension and type to the entity
    this.dimension = dimension;

    // Assign the type of the entity
    if (type instanceof EntityType) this.type = type;
    else this.type = dimension.world.entityPalette.getType(type) as EntityType;

    // Assign the identifier of the entity
    this.identifier = this.type.identifier;

    // Create the scoreboard identity
    this.scoreboardIdentity = new ScoreboardIdentity(this);

    // If the entity is not a player & has an entry
    if (properties?.storage) {
      // Assign the storage to the entity
      this.storage = new EntityLevelStorage(this, properties.storage);
    } else {
      // Create a new storage for the entity
      this.storage = new EntityLevelStorage(this);

      // Set the identifier of the entity
      this.storage.setIdentifier(this.type.identifier);

      // Assign a new unique id to the entity
      const uniqueId = Entity.createUniqueId(this.type.network, this.runtimeId);

      // Assign the unique id to the storage
      this.storage.setUniqueId(uniqueId);

      // Set the position of the as the dimension spawn position
      this.storage.setPosition(dimension.spawnPosition);
    }

    // Create the maps for the entity
    this.sharedProperties = new EntitySharedProperties(this);
    this.metadata = new EntityActorMetadata(this);
    this.flags = new EntityActorFlags(this);
    this.attributes = new EntityAttributes(this);

    // Iterate over the traits in the storage and add them to the entity
    for (const identifier of this.storage.getTraits()) {
      // Check if the trait exists in the entity palette.
      const traitType = this.world.entityPalette.getTrait(identifier);

      // Get the position of the entity.
      const { x, y, z } = this.position;

      // If the trait does not exist, log an error and skip it.
      if (!traitType) {
        // Log a warning to the console.
        this.world.logger.warn(
          `Skipping EntityTrait for entity §u${this.identifier}§r @ §7(§u${x}§7, §u${y}§7, §u${z}§7)§r, as the trait §u${identifier}§r does not exist in the entity palette.`
        );

        // Skip the trait if it does not exist.
        continue;
      }

      // Add the trait to the entity.
      const trait = this.addTrait(traitType as typeof EntityTrait);

      // Log the loading of the trait.
      this.world.logger.debug(
        `Loaded EntityTrait §u${trait.identifier}§r for entity §u${this.identifier}§r @ §7(§u${x}§7, §u${y}§7, §u${z}§7)§r.`
      );
    }

    // Add the traits of the block type to the entity
    for (const [, trait] of this.type.traits) this.addTrait(trait);
  }

  // --- DEPRECATED - REMOVE IN FUTURE ---

  /**
   * The NBT data of the entity.
   * @deprecated Use `getStorageEntry` and `setStorageEntry` methods instead.
   * Will be removed in version 0.8.14 and above.
   */
  public get nbt(): CompoundTag {
    // Log a warning that the nbt property is deprecated
    this.world.logger.warn(
      `The 'Entity.nbt' property is deprecated and will be removed in a future version. Please use 'Entity.getStorageEntry' and 'Entity.setStorageEntry' methods instead.`
    );

    // Return the storage of the entity
    return this.storage;
  }

  /**
   * The name tag of the entity.
   * @deprecated Use `getNametag` and `setNametag` methods instead.
   * Will be removed in version 0.8.14 and above.
   */
  public get nameTag(): string {
    // Log a warning that the nameTag property is deprecated
    this.world.logger.warn(
      `The 'Entity.nameTag' property is deprecated and will be removed in a future version. Please use 'Entity.getNametag' and 'Entity.setNametag' methods instead.`
    );

    // Return the nametag of the entity
    return this.getNametag();
  }

  /**
   * The name tag of the entity.
   * @deprecated Use `getNametag` and `setNametag` methods instead.
   * Will be removed in version 0.8.14 and above.
   */
  public set nameTag(value: string) {
    // Log a warning that the nameTag property is deprecated
    this.world.logger.warn(
      `The 'Entity.nameTag' property is deprecated and will be removed in a future version. Please use 'Entity.getNametag' and 'Entity.setNametag' methods instead.`
    );

    // Set the nametag of the entity
    this.setNametag(value);
  }

  /**
   * Whether the entity name tag is always visible.
   * @deprecated Use `getNametagAlwaysVisible` and `setNametagAlwaysVisible` methods instead.
   * Will be removed in version 0.8.14 and above.
   */
  public get alwaysShowNameTag(): boolean {
    // Log a warning that the alwaysShowNameTag property is deprecated
    this.world.logger.warn(
      `The 'Entity.alwaysShowNameTag' property is deprecated and will be removed in a future version. Please use 'Entity.getNametagAlwaysVisible' and 'Entity.setNametagAlwaysVisible' methods instead.`
    );

    // Return the nametag visibility of the entity
    return this.getNametagAlwaysVisible();
  }

  /**
   * Whether the entity name tag is always visible.
   * @deprecated Use `getNametagAlwaysVisible` and `setNametagAlwaysVisible` methods instead.
   * Will be removed in version 0.8.14 and above.
   */
  public set alwaysShowNameTag(value: boolean) {
    // Log a warning that the alwaysShowNameTag property is deprecated
    this.world.logger.warn(
      `The 'Entity.alwaysShowNameTag' property is deprecated and will be removed in a future version. Please use 'Entity.getNametagAlwaysVisible' and 'Entity.setNametagAlwaysVisible' methods instead.`
    );

    // Set the nametag visibility of the entity
    this.setNametagAlwaysVisible(value);
  }

  /**
   * The current world the entity is in.
   */
  public get world(): World {
    return this.dimension.world;
  }

  /**
   * Get the position of the entity.
   */
  public get position(): Vector3f {
    return this.storage.getPosition();
  }

  /**
   * Set the position of the entity.
   */
  public set position(position: Vector3f) {
    this.storage.setPosition(position);
  }

  /**
   * Checks if the entity is a player.
   * @returns Whether or not the entity is a player.
   */
  public isPlayer(): this is Player {
    return this.type.identifier === EntityIdentifier.Player;
  }

  /**
   * Checks if the entity is an item.
   * @returns Whether or not the entity is an item.
   */
  public isItem(): boolean {
    return this.type.identifier === EntityIdentifier.Item;
  }

  /**
   * Whether the entity is sneaking or not.
   */
  public get isSneaking(): boolean {
    return this.flags.getActorFlag(ActorFlag.Sneaking) ?? false;
  }

  /**
   * Whether the entity is sprinting or not.
   */
  public get isSprinting(): boolean {
    return this.flags.getActorFlag(ActorFlag.Sprinting) ?? false;
  }

  /**
   * Whether the entity is swimming or not.
   */
  public get isSwimming(): boolean {
    return this.flags.getActorFlag(ActorFlag.Swimming) ?? false;
  }

  /**
   * Get the nametag of the entity.
   * @returns The nametag of the entity.
   */
  public getNametag(): string {
    // Check if the entity has a nameable trait
    const nameable = this.getTrait(EntityNameableTrait);

    // If the entity has a nameable trait, return the nametag from the trait
    if (nameable) return nameable.getNametag();

    // Otherwise, return an empty string
    return "";
  }

  /**
   * Set the nametag of the entity.
   * @param nametag The nametag to set the entity to.
   */
  public setNametag(nametag: string): void {
    // Check if the entity has a nameable trait
    if (!this.hasTrait(EntityNameableTrait)) {
      // If the entity does not have a nameable trait, add the trait
      const trait = this.addTrait(EntityNameableTrait);

      // Set the nametag in the trait
      trait.setNametag(nametag);
    } else {
      // If the entity has a nameable trait, get the trait
      const trait = this.getTrait(EntityNameableTrait);

      // Set the nametag in the trait
      trait.setNametag(nametag);
    }
  }

  /**
   * Get whether the nametag is always visible.
   * @returns Whether the nametag is always visible.
   */
  public getNametagAlwaysVisible(): boolean {
    // Check if the entity has a nameable trait
    const nameable = this.getTrait(EntityNameableTrait);

    // If the entity has a nameable trait, return the nametag visibility from the trait
    if (nameable) return nameable.getNametagAlwaysVisible();

    // Otherwise, return false
    return false;
  }

  /**
   * Set whether the nametag is always visible.
   * @param visible Whether the nametag should be always visible.
   */
  public setNametagAlwaysVisible(visible: boolean): void {
    // Check if the entity has a nameable trait
    if (!this.hasTrait(EntityNameableTrait)) {
      // If the entity does not have a nameable trait, add the trait
      const trait = this.addTrait(EntityNameableTrait);

      // Set the nametag visibility in the trait
      trait.setNametagAlwaysVisible(visible);
    } else {
      // If the entity has a nameable trait, get the trait
      const trait = this.getTrait(EntityNameableTrait);

      // Set the nametag visibility in the trait
      trait.setNametagAlwaysVisible(visible);
    }
  }

  /**
   * Add's an effect to the entity.
   * @param effectType The effect type that will be applied to the entity
   * @param duration The duration of the effect in seconds.
   * @param amplifier The amplifier of the effect.
   * @param showParticles Wether or not the effect will show particles.
   * TODO: Refactor method parameters.
   */
  public addEffect(
    effectType: EffectType,
    duration: number,
    options?: EntityEffectOptions
  ): void {
    // If the entity doesn't have the effects trait, add the trait
    const effectTrait =
      this.getTrait(EntityEffectsTrait) ?? this.addTrait(EntityEffectsTrait);

    // Add the effect to the entity.
    effectTrait.add(effectType, duration * 40, options);
  }

  /**
   * Removes an effect from the entity.
   * @param effectType The effect type to remove from the entity
   */
  public removeEffect(effectType: EffectType): void {
    const effectTrait = this.getTrait(EntityEffectsTrait);
    if (!effectTrait || !effectTrait.has(effectType)) return;

    effectTrait.remove(effectType);
  }

  /**
   * Checks whether the entity has the effect or not.
   * @param effectType The effect type to check if the entity has.
   * @returns whether the entity has the effect or not.
   */
  public hasEffect(effectType: EffectType): boolean {
    const effectTrait = this.getTrait(EntityEffectsTrait);
    return effectTrait?.has(effectType) ?? false;
  }

  /**
   * Whether the entity has the specified trait.
   * @param trait The trait to check for
   * @returns Whether the entity has the trait
   */
  public hasTrait(trait: string | typeof EntityTrait): boolean {
    return this.traits.has(
      typeof trait === "string" ? trait : trait.identifier
    );
  }

  /**
   * Computes the view direction vector based on the current pitch and yaw rotations.
   *
   * @returns A Vector3f representing the direction the view is pointing.
   */
  public getViewDirection(): Vector3f {
    // Convert pitch and yaw angles from degrees to radians
    const pitchRadians = this.rotation.pitch * (Math.PI / 180);
    const yawRadians = -this.rotation.headYaw * (Math.PI / 180); // Invert yaw for correct orientation

    // Calculate the direction vector components
    return new Vector3f(
      Math.sin(yawRadians) * Math.cos(pitchRadians), // X component of the view vector
      -Math.sin(pitchRadians), // Y component of the view vector (negative for correct orientation)
      Math.cos(yawRadians) * Math.cos(pitchRadians) // Z component of the view vector
    );
  }

  /**
   * Computes the entity's head location
   */
  public getHeadLocation(): Vector3f {
    // Get the collision trait
    const collision = this.getTrait(EntityCollisionTrait);

    // Get the height of the entity
    const height = collision?.height ?? 1.62;

    // Compute the head location
    return this.position.add(new Vector3f(0, height, 0));
  }

  /**
   * Sets and sends the entity head rotation
   * @param rotation The new entity's head rotation
   */
  public setRotation(rotation: Rotation): void {
    // Set the entity rotation
    this.rotation.set(rotation);

    // Update the position of the entity
    return this.teleport(this.position);
  }

  /**
   * Gets the specified trait from the entity.
   * @param trait The trait to get from the entity
   * @returns The trait if it exists, otherwise null
   */
  public getTrait<T extends typeof EntityTrait>(trait: T): InstanceType<T>;

  /**
   * Gets the specified trait from the entity.
   * @param trait The trait to get from the entity
   * @returns The trait if it exists, otherwise null
   */
  public getTrait(trait: string): EntityTrait | null;

  /**
   * Gets the specified trait from the entity.
   * @param trait The trait to get from the entity
   * @returns The trait if it exists, otherwise null
   */
  public getTrait(trait: string | typeof EntityTrait): EntityTrait | null {
    return this.traits.get(
      typeof trait === "string" ? trait : trait.identifier
    ) as EntityTrait | null;
  }

  /**
   * Removes the specified trait from the entity.
   * @param trait The trait to remove
   */
  public removeTrait(trait: string | typeof EntityTrait): void {
    // Get the trait from the entity
    const instance = this.traits.get(
      typeof trait === "string" ? trait : trait.identifier
    );

    // Call the onRemove trait event
    instance?.onRemove?.();

    // Get the identifier of the trait
    const identifier = typeof trait === "string" ? trait : trait.identifier;

    // Remove the trait from the entity
    this.traits.delete(identifier);

    // Remove the trait from the entities storage
    this.storage.removeTrait(identifier);
  }

  /**
   * Adds a trait to the entity.
   * @param trait The trait to add to the entity.
   * @param options The additional options to pass to the trait.
   * @returns The trait instance that was added to the entity.
   */
  public addTrait<T extends typeof EntityTrait>(
    trait: T | EntityTrait,
    options?: ConstructorParameters<T>[1]
  ): InstanceType<T> {
    // Check if the trait already exists
    if (this.traits.has(trait.identifier))
      return this.getTrait(trait.identifier) as InstanceType<T>;

    // Attempt to add the trait to the entity
    try {
      if (trait instanceof EntityTrait) {
        // Add the trait to the entity
        this.traits.set(trait.identifier, trait);

        // Call the onAdd trait event
        trait.onAdd?.();

        // Return the trait that was added
        return trait as InstanceType<T>;
      } else {
        // Create a new instance of the trait
        const instance = new trait(this, options) as InstanceType<T>;

        // Add the trait to the entity
        this.traits.set(trait.identifier, instance);

        // Call the onAdd trait event
        instance.onAdd?.();

        // Add the trait to the entities storage
        this.storage.addTrait(instance.identifier);

        // Return the trait that was added
        return instance;
      }
    } catch (reason) {
      // Log the error to the console
      this.serenity.logger.error(
        `Failed to add trait "${trait.identifier}" to entity "${this.type.identifier}:${this.uniqueId}" in dimension "${this.dimension.identifier}"`,
        reason
      );
    }

    // Return null as the trait was not added
    return null as InstanceType<T>;
  }

  /**
   * Get the nbt storage of the entity.
   * @returns The nbt storage of the entity.
   */
  public getStorage(): EntityLevelStorage {
    return this.storage;
  }

  /**
   * Check if the entity has a storage entry with the specified name.
   * @param name The name of the storage entry.
   * @returns Whether the entity has the storage entry or not.
   */
  public hasStorageEntry(name: string): boolean {
    return this.storage.has(name);
  }

  /**
   * Get a storage entry from the entity.
   * @param name The name of the storage entry.
   * @returns The storage entry if it exists, otherwise null.
   */
  public getStorageEntry<T extends BaseTag>(name: string): T | null {
    return this.storage.get<T>(name) ?? null;
  }

  /**
   * Sets a storage entry in the entity.
   * @param name The name of the storage entry.
   * @param entry The storage entry to set.
   */
  public setStorageEntry<T extends BaseTag>(name: string, entry: T): void {
    this.storage.set(name, entry);
  }

  /**
   * Adds a storage entry to the entity.
   * @param entry The storage entry to add.
   */
  public addStorageEntry<T extends BaseTag>(entry: T): void {
    // Validate that the entry has a name
    if (!entry.name) throw new Error("The storage entry must have a name.");

    // Add the entry to the storage
    this.storage.add(entry);
  }

  /**
   * Removes a storage entry from the entity.
   * @param name The name of the storage entry to remove.
   */
  public removeStorageEntry(name: string): void {
    this.storage.delete(name);
  }

  /**
   * Gets the chunk the entity is currently in.
   * @returns The chunk the entity is in
   */
  public getChunk(): Chunk {
    // Convert the position to a chunk position
    const cx = this.position.x >> 4;
    const cz = this.position.z >> 4;

    // Get the chunk from the dimension
    return this.dimension.getChunk(cx, cz);
  }

  /**
   * Gets the item the entity is currently holding.
   * @returns The item the entity is holding
   */
  public getHeldItem(): ItemStack | null {
    // Check if the entity has an inventory trait
    if (!this.hasTrait(EntityInventoryTrait)) return null;

    // Get the inventory trait
    const inventory = this.getTrait(EntityInventoryTrait);

    // Return the held item
    return inventory.getHeldItem();
  }

  /**
   * Gets the cardinal direction of the entity.
   * @returns The cardinal direction of the entity.
   */
  public getCardinalDirection(): CardinalDirection {
    // Calculate the cardinal direction of the entity
    // Entity yaw is -180 to 180

    // Calculate the rotation of the entity
    const rotation = (Math.floor(this.rotation.yaw) + 360) % 360;

    // Calculate the cardinal direction
    if (rotation >= 315 || rotation < 45) return CardinalDirection.South;
    if (rotation >= 45 && rotation < 135) return CardinalDirection.West;
    if (rotation >= 135 && rotation < 225) return CardinalDirection.North;
    if (rotation >= 225 && rotation < 315) return CardinalDirection.East;

    return CardinalDirection.South;
  }

  /**
   * Spawns the entity into the dimension.
   */
  public spawn(options?: Partial<EntitySpawnOptions>): this {
    // Spread the default options
    options = {
      initialSpawn: false,
      dimension: this.dimension,
      changedDimensions: false,
      ...options
    };

    // Create a new EntitySpawnedSignal
    const signal = new EntitySpawnedSignal(
      this,
      options as EntitySpawnOptions
    ).emit();

    // Check if the signal was cancelled
    if (!signal) return this;

    // Add the entity to the dimension
    this.dimension.entities.set(this.uniqueId, this);

    // Set the entity as alive
    this.isAlive = true;

    // Trigger the entity onSpawn trait event
    for (const [identifier, trait] of this.traits) {
      // Attempt to trigger the onSpawn trait event
      try {
        // Call the onSpawn trait event
        trait.onSpawn?.(options as EntitySpawnOptions);
      } catch (reason) {
        // Log the error to the console
        this.serenity.logger.error(
          `(EntityTrait::${identifier}) Failed to trigger onSpawn trait event for entity "${this.type.identifier}:${this.uniqueId}" in dimension "${this.dimension.identifier}"`,
          reason
        );

        // Remove the trait from the entity
        this.traits.delete(identifier);
      }
    }

    // Iterate over the players in the dimension
    for (const [, entity] of this.dimension.entities) {
      // Check if the entity is the same as this
      if (entity === this || !entity.isPlayer()) continue; // Check if the entity is a player

      // Fetch the player entity rendering trait
      const trait = entity.getTrait(PlayerEntityRenderingTrait);

      // Check if the player has the trait
      if (trait) trait.addEntity(this); // Add the entity to the player
    }

    // Update the entity actor data & attributes
    const packet = new UpdateAttributesPacket();
    packet.runtimeActorId = this.runtimeId;
    packet.attributes = this.attributes.getAllAttributes();
    packet.inputTick = this.isPlayer()
      ? this.inputInfo.tick
      : this.world.currentTick;

    // Broadcast the packet to the dimension
    this.dimension.broadcast(packet);

    // Return the entity
    return this;
  }

  /**
   * Despawns the entity from the dimension.
   */
  public despawn(options?: Partial<EntityDespawnOptions>): this {
    // Spread the default options
    options = {
      hasDied: false,
      changedDimensions: false,
      ...options
    };

    // Create a new EntityDespawnedSignal
    const signal = new EntityDespawnedSignal(
      this,
      options as EntityDespawnOptions
    ).emit();

    // Check if the signal was cancelled
    if (!signal) return this;

    // Set the entity as not alive
    this.isAlive = false;

    // Remove the entity from the dimension
    this.dimension.entities.delete(this.uniqueId);

    // Get the chunk the entity is in
    const chunk = this.getChunk();

    // Remove the entity from the chunk
    chunk.setEntityStorage(this.uniqueId, null);

    // Trigger the entity onDespawn trait event
    for (const trait of this.traits.values()) {
      // Attempt to trigger the onDespawn trait event
      try {
        // Call the onDespawn trait event
        trait.onDespawn?.(options as EntityDespawnOptions);
      } catch (reason) {
        // Log the error to the console
        this.serenity.logger.error(
          `Failed to trigger onDespawn trait event for entity "${this.type.identifier}:${this.uniqueId}" in dimension "${this.dimension.identifier}"`,
          reason
        );

        // Remove the trait from the entity
        this.traits.delete(trait.identifier);
      }
    }

    // Iterate over the players in the dimension
    for (const [, entity] of this.dimension.entities) {
      // Check if the entity is the the same as this
      if (entity === this || !entity.isPlayer()) continue; // Check if the entity is a player

      // Fetch the player entity rendering trait
      const trait = entity.getTrait(PlayerEntityRenderingTrait);

      // Check if the player has the trait
      if (trait) trait.removeEntity(this); // Remove the entity from the player
    }

    // Return the entity
    return this;
  }

  /**
   * Kills the entity.
   * @param options The options for the entity death.
   */
  public kill(options?: Partial<EntityDeathOptions>): void {
    // Spread the default options
    options = {
      killerSource: null,
      damageCause: ActorDamageCause.None,
      ...options
    };

    // Create a new EntityDieSignal
    new EntityDiedSignal(this, options as EntityDeathOptions).emit();

    // Trigger the onDeath trait event for the entity
    for (const [, trait] of this.traits)
      trait.onDeath?.(options as EntityDeathOptions);

    // Set the entity as not alive
    this.isAlive = false;

    // Schedule the entity to despawn
    this.dimension.schedule(50).on(() => {
      // If the entity is not a player, despawn the entity
      if (!this.isPlayer()) this.despawn();
      // Manually trigger the onDespawn trait event for players
      // We does this because the player has the option to disconnect at the respawn screen
      else {
        // Iterate over the traits of the entity
        for (const trait of this.traits.values())
          trait.onDespawn?.({ hasDied: true, changedDimensions: false });
      }
    });
  }

  /**
   * Causes a player to interact with the entity.
   * @param origin The player that is interacting with the entity.
   * @param method The method that the player used to interact with the entity.
   */
  public interact(origin: Player, method: EntityInteractMethod): void {
    if (method === EntityInteractMethod.Interact) {
      const signal = new PlayerInteractWithEntitySignal(
        origin,
        this,
        origin.getHeldItem(),
        null
      );
      if (!signal.emit()) return;
    } else {
      const signal = new EntityHitSignal(origin, this);

      if (!signal.emit()) return;
    }

    // Check if the method is attack, if so called the onAttackEntity method of the attacking entity
    if (method === EntityInteractMethod.Attack) {
      this.lastDamageSource = origin;
      this.lastDamageStamp = this.world.currentTick;

      // Iterate over the traits of the entity
      for (const trait of origin.traits.values()) {
        // Attempt to trigger the onAttackEntity trait event
        try {
          // Call the onAttackEntity trait event
          trait.onAttackEntity?.(this);
        } catch (reason) {
          // Log the error to the console
          this.serenity.logger.error(
            `Failed to trigger onAttackEntity trait event for entity "${origin.type.identifier}:${origin.uniqueId}" in dimension "${origin.dimension.identifier}"`,
            reason
          );

          // Remove the trait from the entity
          this.traits.delete(trait.identifier);
        }
      }
    }

    // Trigger the entity onInteract trait event
    for (const trait of this.traits.values()) {
      // Attempt to trigger the onInteract trait event
      try {
        // Call the onInteract trait event
        trait.onInteract?.(origin, method);
      } catch (reason) {
        // Log the error to the console
        this.serenity.logger.error(
          `Failed to trigger onInteract trait event for entity "${this.type.identifier}:${this.uniqueId}" in dimension "${this.dimension.identifier}"`,
          reason
        );

        // Remove the trait from the entity
        this.traits.delete(trait.identifier);
      }
    }
  }

  /**
   * Get a container from the entity.
   * @param name The name of the container.
   */
  public getContainer(
    name: ContainerName,
    dynamicId?: number
  ): Container | null {
    // Check if a dynamic id was provided
    if (dynamicId) {
      // Check if the entity has an inventory trait
      if (!this.hasTrait(EntityInventoryTrait)) return null;

      // Get the inventory trait
      const { container } = this.getTrait(EntityInventoryTrait);

      // Iterate over the items in the container
      for (const item of container.storage) {
        // Check if the item is valid
        if (!item) continue;

        // Check if the item has a ItemStackBundleTrait
        if (item.hasTrait(ItemStackBundleTrait)) {
          // Get the bundle trait
          const _bundle = item.getTrait(ItemStackBundleTrait);

          // Check if the bundle has the dynamic id
          // if (bundle.dynamicId === dynamicId) return bundle.container;
        }
      }
    }

    // Switch name of the container
    switch (name) {
      default: {
        // Return null if the container name is not valid
        return null;
      }

      case ContainerName.Armor:
      case ContainerName.Offhand: {
        if (!this.hasTrait(EntityEquipmentTrait))
          throw new Error("The player does not have an equipment trait.");

        // Get the equipment trait
        const equipment = this.getTrait(EntityEquipmentTrait);

        // Check if the container name is armor or offhand
        if (name === ContainerName.Armor) return equipment.armor;
        else return equipment.offhand;
      }

      case ContainerName.Hotbar:
      case ContainerName.Inventory:
      case ContainerName.HotbarAndInventory: {
        // Check if the entity has an inventory trait
        if (!this.hasTrait(EntityInventoryTrait))
          throw new Error("The entity does not have an inventory trait.");

        // Get the inventory trait
        const inventory = this.getTrait(EntityInventoryTrait);

        // Return the inventory container
        return inventory.container;
      }
    }
  }

  /**
   * Sets the position of the entity.
   * @param vector The position to set.
   */
  public setMotion(vector?: Vector3f): void {
    // Update the velocity of the entity
    this.velocity.x = vector?.x ?? this.velocity.x;
    this.velocity.y = vector?.y ?? this.velocity.y;
    this.velocity.z = vector?.z ?? this.velocity.z;
  }

  /**
   * Adds motion to the entity.
   * @param vector The motion to add.
   */
  public addMotion(vector: Vector3f): void {
    // Update the velocity of the entity
    const motion = this.velocity.add(vector);

    // Set the motion of the entity
    this.setMotion(motion);
  }

  /**
   * Clears the motion of the entity.
   */
  public clearMotion(): void {
    this.velocity.x = 0;
    this.velocity.y = 0;
    this.velocity.z = 0;

    // Set the motion of the entity
    this.setMotion();
  }

  /**
   * Applies an impulse to the entity.
   * @param vector The impulse to apply.
   */
  public applyImpulse(vector: Vector3f): void {
    // Update the velocity of the entity
    this.velocity.x += vector.x;
    this.velocity.y += vector.y;
    this.velocity.z += vector.z;

    // Set the motion of the entity
    this.setMotion();
  }

  /**
   * Teleport the entity to a new position.
   * @param position The position to teleport the entity to.
   * @param dimension The dimension to teleport the entity to; optional.
   */
  public teleport(position: Vector3f, dimension?: Dimension): void {
    // Iterate over the traits of the entity
    for (const [identifier, trait] of this.traits) {
      // Attempt to trigger the onTeleport trait event
      try {
        // Call the onTeleport trait event
        trait.onTeleport?.({
          from: this.position,
          to: position,
          changedDimensions: !!dimension
        });
      } catch (reason) {
        // Log the error to the console
        this.serenity.logger.error(
          `(EntityTrait::${identifier}) Failed to trigger onTeleport trait event for entity "${this.type.identifier}:${this.uniqueId}" in dimension "${this.dimension.identifier}"`,
          reason
        );

        // Remove the trait from the entity
        this.traits.delete(identifier);
      }
    }

    // Set the position of the entity
    this.position = position;

    // Check if a dimension was provided
    if (dimension) this.changeDimension(dimension);

    // Create a new MoveActorDeltaPacket
    const packet = new MoveActorDeltaPacket();

    // Assign the packet properties
    packet.runtimeId = this.runtimeId;
    packet.flags = MoveDeltaFlags.All;
    packet.x = position.x;
    packet.y = position.y;
    packet.z = position.z;
    packet.yaw = this.rotation.yaw;
    packet.headYaw = this.rotation.headYaw;
    packet.pitch = this.rotation.pitch;

    // Adjust the y position to account for the player's collision height
    if (this.isPlayer()) packet.y += this.getCollisionHeight();

    // Indicate that the entity must move
    packet.flags |= MoveDeltaFlags.ForceMove;

    // Check if the entity is on the ground
    if (this.onGround) packet.flags |= MoveDeltaFlags.OnGround;

    // Broadcast the packet to the dimension
    this.dimension.broadcast(packet);
  }

  /**
   * Changes the dimension of the entity.
   * @param dimension The dimension to change to.
   */
  public changeDimension(dimension: Dimension): void {
    // Check if the dimension is the same as the current dimension
    if (this.dimension === dimension) return;

    // Despawn the entity from the current dimension
    this.despawn({ changedDimensions: true });

    // Create a new EntityDimensionChangeSignal
    new EntityDimensionChangeSignal(this, this.dimension, dimension).emit();

    // Set the dimension of the entity
    this.dimension = dimension;

    // Spawn the entity in the new dimension
    this.spawn({ changedDimensions: true });
  }

  /**
   * Get the collision height of the entity.
   * @note This method depends on the `EntityCollisionTrait` trait.
   * @returns The collision height of the entity.
   */
  public getCollisionHeight(): number {
    // Check if the entity has a collision trait
    if (!this.hasTrait(EntityCollisionTrait))
      return EntityCollisionTrait.defaultHeight;

    // Get the collision trait
    const collision = this.getTrait(EntityCollisionTrait);

    // Return the collision height
    return collision.height;
  }

  /**
   * Set the collision height of the entity.
   * @note This method depends on the `EntityCollisionTrait` trait.
   * @param height The collision height to set.
   */
  public setCollisionHeight(height: number): void {
    // Get the collision trait of the entity
    const collision = this.hasTrait(EntityCollisionTrait)
      ? this.getTrait(EntityCollisionTrait)
      : this.addTrait(EntityCollisionTrait);

    // Set the collision height
    collision.height = height;
  }

  /**
   * Get the collision width of the entity.
   * @note This method depends on the `EntityCollisionTrait` trait.
   * @returns The collision width of the entity.
   */
  public getCollisionWidth(): number {
    // Check if the entity has a collision trait
    if (!this.hasTrait(EntityCollisionTrait))
      return EntityCollisionTrait.defaultWidth;

    // Get the collision trait
    const collision = this.getTrait(EntityCollisionTrait);

    // Return the collision width
    return collision.width;
  }

  /**
   * Set the collision width of the entity.
   * @note This method depends on the `EntityCollisionTrait` trait.
   * @param width The collision width to set.
   */
  public setCollisionWidth(width: number): void {
    // Get the collision trait of the entity
    const collision = this.hasTrait(EntityCollisionTrait)
      ? this.getTrait(EntityCollisionTrait)
      : this.addTrait(EntityCollisionTrait);

    // Set the collision width
    collision.width = width;
  }

  /**
   * Checks if the entity has gravity.
   * @note This method depends on the `EntityGravityTrait` trait.
   * @returns Whether or not the entity has gravity.
   */
  public hasGravity(): boolean {
    return this.hasTrait(EntityGravityTrait);
  }

  /**
   * Gets the gravity force of the entity.
   * @note This method depends on the `EntityGravityTrait` trait.
   * @returns The gravity force of the entity.
   */
  public getGravityForce(): number {
    // Check if the entity has a gravity trait
    if (!this.hasTrait(EntityGravityTrait))
      return EntityGravityTrait.defaultForce;

    // Get the gravity trait
    const gravity = this.getTrait(EntityGravityTrait);

    // Return the gravity force
    return gravity.force;
  }

  /**
   * Sets the gravity force of the entity.
   * @note This method depends on the `EntityGravityTrait` trait.
   * @param force The gravity force to set.
   */
  public setGravityForce(force: number): void {
    // Get the gravity trait of the entity
    const gravity = this.hasTrait(EntityGravityTrait)
      ? this.getTrait(EntityGravityTrait)
      : this.addTrait(EntityGravityTrait);

    // Set the gravity force
    gravity.force = force;
  }

  /**
   * Gets the selected inventory slot of the entity.
   * @returns The selected hotbar index of the entity.
   */
  public getSelectedSlot(): number {
    // Check if the entity has an inventory trait
    if (!this.hasTrait(EntityInventoryTrait))
      throw new Error("The entity does not have an inventory trait.");

    // Get the inventory trait
    const inventory = this.getTrait(EntityInventoryTrait);

    // Return the selected slot
    return inventory.selectedSlot;
  }

  /**
   * Forces the entity to drop an item from its inventory.
   * @param slot The slot to drop the item from.
   * @param amount The amount of items to drop.
   * @param container The container to drop the item from.
   * @returns Whether or not the item was dropped.
   */
  public dropItem(slot: number, amount: number, container: Container): boolean {
    // Check if the entity has an inventory trait
    if (!this.hasTrait(EntityInventoryTrait)) return false;

    // Get the item from the slot
    let itemStack = container.getItem(slot);

    // Check if the item is valid
    if (!itemStack) return false;

    // Create a new ItemStackDropOptions
    const options = {
      origin: this,
      amount,
      cancelled: false
    };

    // Iterate over the traits of the item stack
    for (const [identifier, trait] of itemStack.traits) {
      try {
        // Call the onDropped trait event
        trait.onDropped?.(options);
      } catch (reason) {
        // Log the error to the console
        this.world.serenity.logger.error(
          `Failed to trigger onDropped trait event for item "${identifier}" in entity "${this.type.identifier}:${this.uniqueId}" in dimension "${this.dimension.identifier}"`,
          reason
        );

        // Remove the trait from the item stack
        itemStack.traits.delete(identifier);
      }
    }

    // Create a new EntityDropItemSignal
    const signal = new EntityDropItemSignal(this, itemStack, amount);

    // Check if the signal was cancelled
    if (!signal.emit() || options.cancelled) {
      // Update the item stack
      itemStack.update();

      // Check if the container is a cursor & if the entity is a player
      if (container.identifier === ContainerId.Ui && this.isPlayer()) {
        // Check if the player has an opened container
        if (!this.openedContainer) return false;

        // Get the item stack from the cursor container
        const itemStack = container.takeItem(slot, amount);
        if (!itemStack) return false;

        // Attempt to add the itemStack to the opened container
        if (!this.openedContainer.addItem(itemStack)) {
          // Get the inventory trait of the player
          const inventory = this.getTrait(EntityInventoryTrait);

          // Check if the inventory is valid
          if (!inventory) return false;

          // Add the itemStack to the player's inventory
          inventory.container.addItem(itemStack);
        }
      }

      // Return false as the item was not dropped
      return false;
    }

    // Take the amount of items from the item stack
    itemStack = container.takeItem(slot, amount)!;

    // Get the entity's position and rotation
    const { x, y, z } = this.position;
    const { headYaw, pitch } = this.rotation;

    // Normalize the pitch & headYaw, so the entity will be spawned in the correct direction
    const headYawRad = (headYaw * Math.PI) / 180;
    const pitchRad = (pitch * Math.PI) / 180;

    // Calculate the velocity of the entity based on the entity's rotation
    const vx = -Math.sin(headYawRad) * Math.cos(pitchRad);
    const vy = -Math.sin(pitchRad);
    const vz = Math.cos(headYawRad) * Math.cos(pitchRad);

    // Calculate the velocity of the entity based on the entity's rotation
    const velocity = new Vector3f(vx, vy, vz).divide(2);

    // Spawn the entity in the dimension
    signal.itemStackEntity = this.dimension.spawnItem(
      itemStack,
      new Vector3f(x, y + 1.25, z)
    );

    // Set the velocity of the entity
    signal.itemStackEntity.addMotion(velocity.add(this.velocity));

    // Return true as the item was dropped
    return true;
  }

  /**
   * Whether or not the entity has a tag.
   * @param tag The tag to check.
   * @returns Whether or not the entity has the tag.
   */
  public hasTag(tag: string): boolean {
    return this.tags.has(tag);
  }

  /**
   * Gets the tags of the entity.
   * @returns The tags of the entity.
   */
  public getTags(): Array<string> {
    return [...this.tags];
  }

  /**
   * Adds a tag to the entity.
   * @param tag The tag to add.
   * @returns Whether or not the tag was added.
   */
  public addTag(tag: string): boolean {
    // Check if the tag already exists
    if (this.tags.has(tag)) return false;

    // Tags are read-only
    this.tags.add(tag);

    // Return true as the tag was added
    return true;
  }

  /**
   * Removes a tag from the entity.
   * @param tag The tag to remove.
   * @returns Whether or not the tag was removed.
   */
  public removeTag(tag: string): boolean {
    // Check if the tag exists
    if (!this.tags.has(tag)) return false;

    // Remove the tag from the entity
    this.tags.delete(tag);

    // Return true as the tag was removed
    return true;
  }

  /**
   * Executes a command as the entity.
   * @param command The command to execute.
   * @returns The response of the command.
   */
  public executeCommand<T = unknown>(command: string): CommandResponse<T> {
    // Check if the command starts with a slash, remove it if it does not
    if (command.startsWith("/")) command = command.slice(1);

    // Create a new command execute state
    const state = new CommandExecutionState(
      this.world.commandPalette.getAll(),
      command,
      this
    );

    // Execute the command state
    return state.execute() as CommandResponse<T>;
  }

  /**
   * Executes a command in the dimension asynchronously.
   * @param command The command to execute.
   * @returns The response of the command.
   */
  public async executeCommandAsync<T = unknown>(
    command: string
  ): Promise<CommandResponse<T>> {
    // Check if the command starts with a slash, remove it if it does not
    if (command.startsWith("/")) command = command.slice(1);

    // Create a new command execute state
    const state = new CommandExecutionState(
      this.world.commandPalette.getAll(),
      command,
      this
    );

    // Execute the command state
    return (await state.execute()) as Promise<CommandResponse<T>>;
  }

  /**
   * Make an entity play an animation.
   * @param animation The animation name to play.
   * @param options Additional options for the animation.
   */
  public playAnimation(
    animation: string,
    options?: PlayerAnimationOptions
  ): void {
    // Create a new AnimateEntityPacket
    const packet = new AnimateEntityPacket();

    // Assign the packet properties
    packet.animation = animation;
    packet.nextState = options?.nextState ?? "default";
    packet.stopExpression =
      options?.stopExpression ?? "query.any_animation_finished";
    packet.stopExpressionVersion = 1;
    packet.controller = options?.controller ?? "__runtime_controller";
    packet.blendOutTime = options?.blendOutTime ?? 0.0;
    packet.actorRuntimeIds = [this.runtimeId];

    // Check if a players array was provided
    if (options?.players) {
      // Iterate over the players and send the packet to each player
      for (const player of options.players) player.send(packet);
    } else {
      // Broadcast the packet to the dimension
      this.dimension.broadcast(packet);
    }
  }

  /**
   * Creates a new unique id for the entity.
   * @param network The network id of the entity type
   * @param runtimeId The current runtime id of the entity
   * @returns A generated unique id for the entity
   */
  public static createUniqueId(network: number, runtimeId: bigint): bigint {
    // Generate a unique id for the entity
    const unique = BigInt(Math.abs(Date.now() >> 4) & 0x1_ff);

    return BigInt(network << 19) | (unique << 10n) | runtimeId;
  }
}

export { Entity };
